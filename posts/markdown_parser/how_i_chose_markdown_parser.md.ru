## Вступление

Я обожаю Markdown. Это мощный, но вместе с тем лаконичный язык разметки. В его основе лежит концепция разделения данных и представления, что делает его очень удобным в ряде применений, например в системах контроля версий. Поэтому, например, Markdown является стандартом для документации на GitHub.

Markdown широко распространен в вебе как язык разметки для текстовых редакторов: на сайтах для ведения блогов, в вики проектах и т. д. Я сам ежедневно использую Markdown, и не только в разработке ПО, но и для ведения заметок. Я использую программу [Obsidian](https://obsidian.md/): ide-подобный текстовый редактор Markdown для управления базой знаний.

> Вообще говоря, Obsidian - одна из лучших программ для ведения заметок. Если вы еще не слышали о ней или о принципе [zettelkasten](https://en.wikipedia.org/wiki/Zettelkasten), то, возможно, вам стоит заглянуть [сюда](https://www.reddit.com/r/ObsidianMD/) и [сюда](https://zettelkasten.de/introduction/).

Недавно я решил создать свой [сайт](https://logosnikita.com), и мне понадобилось выбрать язык для разметки статей. Разумеется, я выбрал Markdown. Оставалось только определиться со всем остальным стеком.

Поискав готовые решения, я наткнулся на [jekyll](https://jekyllrb.com/) - генератор статических сайтов на основе Markdown. Он выглядел неплохим решением для минималистов, но, на мой взгляд, имел слишком много ограничений. В итоге я решил остаться на своем любимом фреймворке [vue.js](https://vuejs.org/), а для конвертации Markdown в HTML использовать библиотеку. И вот тут началось самое интересное...

## Выбор инструмента

Благодаря открытости, сравнительной простоте и популярности Markdown среди разработчиков, существует несколько десятков его реализаций на различных языках программирования. Далеко не полный список реализаций можно посмотреть [здесь](https://github.com/markdown/markdown.github.com/wiki/Implementations).

Когда я увидел это множество вариантов, первой мыслью было написать все самому с нуля ~~и пальцы сами потянулись к клавиатуре~~, но я мужественно пересилил себя. Вместо этого я решил сравнить парсеры и выбрать лучший.

Конечно, для рендеринга статических страниц можно было бы использовать реализацию на любом языке, но я решил остановиться на pure-JavaScript решениях для большей гибкости.
Так у меня осталось 9 кандидатов:
1. [commonmark.js](https://github.com/commonmark/commonmark.js)
2. [markdown-js](https://github.com/evilstreak/markdown-js)
3. [markdown-it](https://github.com/markdown-it/markdown-it)
4. MarkdownDeep - [GitHub](https://github.com/toptensoftware/markdowndeep) и [сайт](https://www.toptensoftware.com/markdowndeep/)
5. [Marked](https://github.com/markedjs/marked)
6. [remark](https://github.com/remarkjs/remark)
7. [remarkable](https://github.com/jonschlinkert/remarkable)
8. [Showdown](https://github.com/showdownjs/showdown)
9. [texts.js](https://github.com/sheremetyev/texts.js)

Для сравнения парсеров я составил такой список параметров:
1. лицензия
2. инфраструктура
    1. документация
    2. наличие демо
    3. живое коммьюнити
3. поддержка определенного подмножества синтаксиса Markdown
4. возможность модифицировать логику работы парсера
5. производительность

### Лицензии

Итак, приступим! Начнем с лицензии.
Здесь все просто:
1. [Лицензия commonmark.js](https://github.com/commonmark/commonmark.js/blob/master/LICENSE) - 2-clause BSD, две зависимости, обе под MIT
2. [Лицензия markdown-js](https://github.com/evilstreak/markdown-js#license) - MIT
3. [Лицензия markdown-it](https://github.com/markdown-it/markdown-it/blob/master/LICENSE) - MIT
4. [Лицензия MarkdownDeep](https://github.com/toptensoftware/markdowndeep/blob/master/MarkdownDeepJS/MarkdownDeep%20License.txt) - Apache 2.0
5. [Лицензия Marked](https://github.com/markedjs/marked/blob/master/LICENSE.md) - MIT, ссылается на Джона Грубера, создателя языка Markdown, распространяющего его под лицензией 3-clause BSD, что довольно мило :)
6. [Лицензия remark](https://github.com/remarkjs/remark/blob/main/license) - MIT
7. [Лицензия remarkable](https://github.com/jonschlinkert/remarkable/blob/master/LICENSE) - MIT
8. [Лицензия Showdown](https://github.com/showdownjs/showdown/blob/master/LICENSE) - MIT
9. [Лицензия texts.js](https://github.com/sheremetyev/texts.js/blob/master/LICENSE) - Apache 2.0

Другими словами, все проекты распространяются под свободными лицензиями, чего и следовало ожидать.


### Инфраструктура

На документации останавливаться не будем: у всех проектов она имеется.

С демо дела чуть хуже:
1. [Демо commonmark.js](https://spec.commonmark.org/dingus/)
2. Демо markdown-js - отсутствует
3. [Демо markdown-it](https://markdown-it.github.io/)
4. [Демо MarkdownDeep](https://www.toptensoftware.com/markdowndeep/dingus)
5. [Демо Marked](https://marked.js.org/demo/)
6. Демо remark - отсутствует
7. [Демо remarkable](https://jonschlinkert.github.io/remarkable/demo/)
8. [Демо Showdown](http://demo.showdownjs.com/)
9. Демо texts.js - отсутствует

Поддержку коммьюнити оценить сложно, не погрузившись в проект и не столкнувшись с трудностями. Косвенно проект можно оценить по числу звездочек на GitHub, но по этическим соображениям я не буду этого делать.

Что касается активности, то:
1. проект markdown-js в данный момент не поддерживается, последний коммит в 2019 году
2. texts.js - последний коммит в 2013 году
3. remarkable - последний коммит в сентябре 2021 (в целом не так уж давно)
4. остальные проекты имеют коммиты в этом году, так что можно считать их активными.

### Синтаксис

Пожалуй, это самая важная часть. Для начала я составил список необходимой мне разметки:

<details>
  <summary>Требования к разметке</summary>

---

@include "./partials/requirements.md.ru"

---

</details>

Для тестирования парсеров я составил текст с примерами всей необходимой разметки:

[Тестовый текст (raw)](https://logosnikita.com/posts/markdown_parser/partials/text_for_testing.md)

<details>
  <summary>Тестовый текст (preview)</summary>

---

@include "./partials/text_for_testing.md"

---

</details>

Разбираться с установкой всех парсеров мне не хотелось, поэтому я тестировал только те, у которых было демо. При желании вы можете протестировать остальные самостоятельно, используя тестовый текст выше (или любой другой).

Итак, перейдем к результатам. Но сначала:

#### Небольшая ремарка

После написания статьи я узнал, что стандарт Markdown поддерживает функцию переноса строки в текстовом блоке (аналог тега `<br>` в HTML). Для переноса нужно добавить два пробела в конце предыдущей строки, а новую начать на следующей строке.

Все из исследованных парсеров поддерживают эту функцию. На момент написания этой статьи я не знал об этом, и проверял в парсерах работоспособность переноса строки без отбивки из двух пробелов.

Мне отбивка пробелами кажется громоздкой и неудобной, а также не наглядной, ведь пробелы не отображаются в окне текстового редактора. Поэтому, я решил оставить проверку поддержки "переносов без отбивки" в статье, однако стоит воспринимать ее не как критичную фичу, а как приятный бонус.

#### commonmark.js

Что не работает:
1. перевод строки в текстовых блоках без отбивки
2. подсветка синтаксиса
3. выделение текста
    1. зачеркнутый текст (приходится использовать `<del>`)
    2. выделение цветом (приходится использовать `<mark>`)
    3. подстрочный регистр
    4. надстрочный регистр
4. таблицы

Немного неудобно, что в демо не работают переходы по ссылкам и не отрисовывается видео с YouTube, но сырой код HTML вроде верный

#### markdown-it

Все работает!

Можно включить по желанию:
1. перевод строки в текстовых блоках без отбивки
2. парсинг HTML

#### MarkdownDeep

Пожалуй, это самый косячный парсер Markdown из проверенных.

Что не работает:
1. перевод строки в текстовых блоках без отбивки
2. вложенная цитата интерферирует со списком
3. блоки кода
    1. перевод строки в коде
    2. подсветка синтаксиса
    3. экранирование спец. символов
    4. код почему-то дублируется: один раз как код и еще раз как текст
4. выделение текста
    1. зачеркнутый текст
    2. выделение цветом
    3. подстрочный регистр
    4. надстрочный регистр
5. iframe не работает

Баги с цитатами и блоками кода наглядно:

![Bugs](https://logosnikita.com/posts/markdown_parser/images/markdowndeep_bugs.png)

Что не так:
1. Текст `- list in quote` должен быть на следующей строке.
2. Весь текст из кодового блока идет в одну линию
3. значки \`\`\`<!--`--> вылезли из кодового блока
4. текст из последнего блока повторяется - но уже как Markdown

#### Marked

Что не работает:
1. выделение текста
    1. зачеркнутый текст
    2. выделение цветом
    3. подстрочный регистр
    4. надстрочный регистр
2. таблицы

Можно включить по желанию:
1. перевод строки в текстовых блоках без отбивки
2. В демо синтаксис не подсвечивается. Однако, в конфиге есть поля `"highlight": null` и `"langPrefix": "language-"`, указывающие на то, что как-то можно подключить подсветку синтаксиса. Правда, как это сделать, я не разбирался.

Не отрисовывается iframe с видео с YouTube, но сырой код HTML вроде верный.

#### remarkable

Все работает!

Можно включить по желанию:
1. перевод строки в текстовых блоках без отбивки
2. парсинг HTML

Проект очень сильно напоминает markdown-it, и неспроста (см. далее).

#### Showdown

Что не работает
1. Заголовки h5 и h6
2. перевод строки в текстовых блоках без отбивки
3. подсветка синтаксиса
4. выделение текста
    1. выделение цветом
    2. подстрочный регистр
    3. надстрочный регистр
6. iframe не работает

С заголовками творится что-то странное: `#` транслируется в `<h3>`, `##` в `<h4>` и т. д., а на заголовки 5 и 6 уровней тегов в HTML не остается, и они вставляются как простой текст. Это мешает их нормальной стилизации через CSS, а также приводит к багу с переносом на следующую строчку:

![Bugs](https://logosnikita.com/posts/markdown_parser/images/showdown_bugs.png)

В интерфейсе демо есть галочки для включения опций, но они не работают. При попытке нажать галочку страница перезагружается, а галочка не проставляется.

Судя по названию одной из галочек (`simpleLineBreaks`) перевод строки без отбивки должен работать, но у меня заставить его работать не получилось.

#### Bonus: Obsidian

В конце концов мне захотелось проверить и свой заметочник Obsidian, так как именно в нем я буду набирать статьи, которые затем пойдут на сайт. (Сами понимаете, где я набирал *эту* статью \^\_\^ ). К моей радости, он без труда справился со всем за исключением subscript-а и superscript-а. Но это простительно 🙃.

#### Bonus 2: PyCharm

Так как код сайта я пишу в PyCharm Community Edition, а у него есть встроенный просмотрщик Markdown, то... ну вы поняли :)

Что не работает:
1. перевод строки в текстовых блоках без отбивки
2. выделение текста
    1. выделение цветом
    2. подстрочный регистр
    3. надстрочный регистр
3. внутренние ссылки не работают внутри ide
4. Эскейпинг символов почему-то отображает слэши перед символами, хотя должен скрывать
5. iframe не работает

Работает выборочно:
1. подсветка синтаксиса доступна только для Python. Возможно, все дело в Community Edition, а в Enterprise Edition поддерживаются и другие языки, но я не проверял.

#### Ремарка

На самом деле в ряде случаев отсутствие поддержки части синтаксиса (к примеру, выделения текста и таблиц) - это не баг, а фича, так как часть парсеров Markdown придерживается спецификации [CommonMark](https://spec.commonmark.org/). Другие парсеры, такие как remarkable, позволяют включать опцию "CommonMark" по желанию.

Спецификация CommonMark нацелена на унификацию языка Markdown. Это может быть полезно, например, при необходимости переноса текста в Markdown между различными системами. Однако, мне для сайта требовался расширенный функционал, так что эти парсеры мне не подошли.

Также в ряде парсеров теги HTML, признанные небезопасными (как `<iframe>`), не рендерятся намеренно. Это называется "санитайзинг HTML". Он полезен, например, если парсер Markdown используется для рендеринга пользовательского контента. Но, так как на моем сайте все статьи буду писать я, эта функция мне будет только мешать.

### Возможность модифицировать логику работы парсера

В основном парсеры работают по следущему алгоритму:

> Markdown -> парсинг -> внутреннее представление -> рендеринг -> HTML

Часть парсеров позволяет изменять логику своей работы. Парсер может давать доступ к функциям парсинга и рендеринга, либо позволять модифицировать внутреннее представление. Это дает возможность добавлять дополнительный функционал, либо модифицировать существующий. Такая расширяемость парсера открывает путь для создания плагинов сообществом.

Я не смог найти упоминаний о расширяемости в документации следующих парсеров:
1. commonmark.js
2. MarkdownDeep

Остальные рассмотрены ниже:

#### markdown-js

markdown-js позволяет получить доступ к внутренним представлениям. Логика работы парсера такая:

> Markdown -> парсинг -> дерево Markdown -> конвертация -> дерево HTML -> рендеринг -> HTML

Промежуточные представления хранятся в виде деревьев в формате [JsonML](http://www.jsonml.org/) и к ним можно получить доступ, вызывая функции парсинга, конвертации и рендеринга по очереди.

#### markdown-it

[Пайплайн markdown-it](https://github.com/markdown-it/markdown-it/blob/master/docs/architecture.md) состоит из парсера и рендерера.

Логика работы парсера описывается правилами, разбитыми на 3 группы: `core`, `block` и `inline`, что бы это ни значило. К существующим правилам можно дописывать свои.

Результатом работы парсера, вместо синтаксического дерева, является список токенов. Разработчики утверждают, что это сделано в целях упрощения алгоритма. И, хотя я не вижу ничего сложного в синтаксическом дереве, у плоской структуры должны быть свои преимущества.

Список токенов также можно модифицировать самостоятельно.

Список токенов передается в рендерер, который также можно расширять, добавляя свои правила.

Список доступных плагинов можно посмотреть [здесь](https://www.npmjs.com/search?q=keywords:markdown-it-plugin).

#### Marked

Логика работы Marked выглядит во многом похоже на остальные парсеры:
> Markdown -> парсер -> синтаксическое дерево -> рендерер -> HTML

Правда, [документация](https://marked.js.org/using_pro) весьма вольно использует термины.

Парсер, который называется `lexer`, управляет набором правил, которые называются `tokenizers`. Можно как добавлять свои токенайзеры, так и модифицировать встроенные при помощи способа, напоминающего наследование, от встроенного объекта, содержащего функции-токенайзеры. При этом если функция в классе-наследнике вернет false, то будет выполнена функция из класса-родителя.

Можно определить функцию `walkTokens`, которая получает на вход синтаксическое дерево и его же должна отдать на выходе. Внутри можно провести любые модификации дерева.

Дерево отдается рендереру, который здесь `parser`, и он вызывает набор правил `renderers`. Как и в случае с парсером, можно и добавить свои функции, и отнаследоваться от существующих.


#### remark

Проект remark разработан с горячей любовью к декомпозиции. Remark использует парсер [mdast-util-from-markdown](https://github.com/syntax-tree/mdast-util-from-markdown), основанный на [micromark](https://github.com/micromark/micromark), синтаксическое дерево [mdast](https://github.com/syntax-tree/mdast), являющееся реализацией [unist](https://github.com/syntax-tree/unist) для Markdown, рендерер [mdast-util-to-markdown](https://github.com/syntax-tree/mdast-util-to-markdown), а также обертку [unified](https://github.com/unifiedjs/unified), чтобы склеить все это воедино. Фуууф!

В общем, разбираться во всем этом мне не очень хочется, тем более что логика работы особо не отличается от других парсеров.

С другой стороны, [список плагинов](https://github.com/remarkjs/remark/blob/main/doc/plugins.md#list-of-plugins) у проекта весьма внушительный, так что, возможно, подход с микрорепозиториями имеет свои плюсы.

#### remarkable

Так как remarkable имеет общие корни с markdown-it (см. далее), то и логика работы у них схожая. Я не вдавался в подробности, так что за тонкостями реализации обращайтесь [сюда](https://github.com/jonschlinkert/remarkable/tree/master/docs).

Список плагинов можно посмотреть [здесь](https://www.npmjs.com/search?q=keywords:remarkable).

#### Showdown

Похоже на то, что [плагины Showdown](https://github.com/showdownjs/showdown/wiki/extensions) представляют собой набор регулярных выражений и функций, последовательно модифицирующих весь текст.

Логику работы можно описать так:

> Markdown -> regex/function 1 -> modified text -> regex/function 2 -> ... -> regex/function n -> HTML

Это довольно топорное решение, позволяющее очень просто создавать плагины. Однако, существенный минус такого подхода заключается в низкой производительности, поскольку каждая функция выполняется независимо и вынуждена заново парсить весь текст.

#### texts.js

Насколько я понял из [документации](https://github.com/sheremetyev/texts.js#textjson), существует возможность получить доступ к внутреннему представлению texts.js, которое является кастомной реализацией JsonML под названием TextJSON.

#### Вывод

Интересно, что, хотя все рассмотренные парсеры имеют общие принципы работы, они сильно различаются в деталях реализаций.

Мне нравится логика реализации markdown-js - она не слишком замороченная и удобная с точки зрения написания плагинов. К сожалению, markdown-js на данный момент не поддерживается, и поэтому я не буду его использовать.

Логика реализаций markdown-it, remarkable и Marked неплоха, но документация смущает своей терминологией.

Remark выглядит как самый хорошо документированный проект, но вместе с тем степень его декомпозиции кажется излишней.

Плагины в Showdown устроены очень просто, но это достигается путем значительного снижения производительности.

Про texts.js вообще трудно что-либо сказать по причине неполной документации.

Итого, с точки зрения плагинов можно смело брать:
1. markdown-it
2. Marked
3. remark
4. remarkable

### Производительность

Можно было бы провести бенчмаркинг самостоятельно, но гораздо проще найти существующие бенчмарки и сравнить их.

#### Поиск бенчмарков

Я нашел 4 бенчмарка:
1. [сommonmark.js benchmark](https://github.com/commonmark/commonmark.js#performance) - 2015
    - commonmark.js
    - markdown-it
    - Marked
    - Showdown
2. [markdown-it benchmark](https://github.com/markdown-it/markdown-it#benchmark) - 2015
    - markdown-it
    - Marked
    - commonmark
3. [remarkable benchmark](https://github.com/jonschlinkert/remarkable#benchmark) - 2014
    - remarkable
    - Marked
    - commonmark
4. [markdown-benchmark](https://github.com/mpneuried/markdown-benchmark#raw-results) - 2015
    - markdown-js
    - Marked
    - showdown

Я не нашел бенчмарков для:
1. MarkdownDeep
2. texts.js
3. remark

Все бенчмарки сделаны примерно в одно время, так что будем считать их примерно сопоставимыми.

Исследования датируются 2014-2015 годами, но будем считать их действительными, так как если бы с тех пор разработчики сильно подняли производительность, это было бы отражено в readme проекта.

Итого, имея эти бенчмарки, мы можем построить такой граф зависимостей:

![Benchmarks](https://logosnikita.com/posts/markdown_parser/images/benchmarks.jpg)

Цвета стрелок здесь совпадают с цветом автора бенчмарка.

#### Сравнение

Производительность измеряется в операциях в секунду, то есть чем больше, тем лучше.

Я посчитал относительную производительность  по каждому из бенчмарков в отдельности:
1. commonmark
    1. showdown = 1
    2. commonmark.js ~ Marked ~ markdown-it = 3
2. markdown-it
    1. commonmark.js = 1
    2. markdown-it = 0.6 (1.28 в режиме CommonMark)
    3. Marked = 1.3 (версия 0.3.5)
3. remarkable
    1. commonmark.js = 1
    2. remarkable = 1.88 (2.34 в режиме CommonMark)
    3. Marked = 0.573 (тут старая и медленная версия - 0.3.2)
4. markdown
    1. Showdown = 1
    2. markdown-js = 0.61
    3. Marked = 2.99

Анализ бенчмарков:
1. Видно, что в среднем commonmark.js, Marked и markdown-it быстрее, чем Showdown, в 3 раза.
2. Данные бенчмарка 2 примерно подтверждают данные бенчмарка 1
3. По бенчмарку 3 remarkable быстрее commonmark.js в 2 раза, то есть быстрее Showdown в 6 раз. Это впечатляющий показатель, но так как он произведен разработчиком remarkable, ему нельзя слишком сильно доверять. Учитывая, что у remarkable и markdown-it одинаковые корни, можно предположить, что и производительность у них примерно одинаковая.
4. По бенчмарку 4 markdown-js медленнее Showdown на 40%

Теперь надо привести все это к общему знаменателю. Самым надежным выглядит бенчмарк 1, так что в качестве единицы возьму производительность Showdown. Итого получаем такую сравнительную таблицу:

| Парсер        | Производительность | Источники оценки |
| :------------ | :----------------- |:---------------- |
| commonmark.js | ~3                 | 1                |
| markdown-js   | ~0.6               | 4                |
| markdown-it   | ~3                 | 1                |
| Marked        | ~3                 | 1, 4             |
| remarkable    | ~3 / ~6            | моя догадка / 3  |
| Showdown      | 1                  | -                |

#### Вывод

Результаты сравнения показывают, что по производительности markdown-js и Showdown катастрофически проигрывают остальным парсерам, в то время как остальные держатся примерно на одном уровне.

Если верить бенчмарку от разработчика remarkable, то он быстрее всех с большим отрывом. Правда, я сомневаюсь в его достоверности.

Было бы интересно посмотреть на производительность парсера remark. Возможно, в другой раз...

Подводя итог, если вам важна производительность, вы можете смело выбирать:
1. commonmark.js
2. markdown-it
3. Marked
4. remarkable

### Окончательный выбор

По результатам сравнения победили два парсера: markdown-it и remarkable. У этих проектов много общего, в том числе общие разработчки.

Если посмотреть в историю версий проектов, то можно узнать много интересного. Так, первым появился проект remarkable. Через несколько месяцев возник markdown-it - скорее всего, как форк remarkable. С тех пор проекты развиваются параллельно.

Оба проекта:
1. имеют лицензию MIT
2. предоставляют рабочее демо
3. безупречно прошли тест на синтаксис
4. дают широкие возможности к модификации своей логики работы
5. имеют много готовых плагинов
6. находятся в лидерах по производительности

Я для себя выбрал remarkable, потому что у него в демо был пример кода и я смог быстро интегрировать его в свой проект.

В целом я не нашел значительных отличий между этими двумя парсерами, так что рекомендую оба!

## Как я настроил парсер

Итак, я выбрал remarkable, и мне предстояло его настроить.

### Что есть из коробки

Я был приятно удивлен, что из коробки он поддерживает много [полезных вещей](https://jonschlinkert.github.io/remarkable/demo/). В том числе и тех, о которых я не знал:

1. Примечания: текст[^sample_footnote]
2. Аббревиатуры: SQL

[^sample_footnote]: Footnote **can have markup**

*[SQL]: Structured Query Language

Но что оказалось действительно полезным, так это поддержка скрываемых блоков (спойлеров):

<details>
  <summary>Нажмите, чтобы увидеть спойлер</summary>

==Это спойлер!==

</details>

### Плагины

В [списке плагинов](https://www.npmjs.com/search?q=keywords:remarkable) есть много интересных.

Себе я установил [remarkable-katex](https://www.npmjs.com/package/remarkable-katex), основанный на библиотеке [KaTeX](https://github.com/KaTeX/KaTeX) для отрисовки формул LaTeX в вебе.

С ним можно делать такие вещи: $ \frac{1}{2} $

И такие:

$$ \frac{1}{2} $$

Если вы знаете японский, вам может пригодиться плагин [remarkable-furigana](https://www.npmjs.com/package/remarkable-furigana), позволяющий отрисовывать над иероглифами их произношение.

Остальные плагины оставлю вам для самостоятельного изучения.

### include

На сайте я храню исходники статей как файлы с текстом Markdown. Для удобства мне понадобилась возможность подключать содержимое одних файлов в другие.

Решать эту задачу средствами remarkable было бы неправильно, поэтому я написал функцию препроцессора, которая получает на вход путь к корневому файлу и рекурсивно вставляет в него необходимые подфайлы.

Например, для такой структуры файлов
- posts/
    - main.md
    - parts/
        - part.md
        - part2.md

Это будет выглядеть примерно так:

```js
// main.md

// absolute path
@include '/posts/parts/part.md'

// or relative path
@include './parts/part2.md'

!!!
```

```js
// part.md
Hello
```

```js
// part2.md
world
```


```js
// output
Hello

world

!!!
```

<details>
  <summary>Для тех, кто заинтересовался, вот код препроцессора:</summary>

@include "./code/preprocessor_code.md"

</details>


### Стили

Для того, чтобы кастомизировать внешний вид статей, я создал свои стили для всех HTML компонентов, получаемых при генерации из Markdown.

<details>
  <summary>Вот моя таблица стилей для тех, кому интересно:</summary>

@include "./code/styles_code.md"

</details>

Для подсветки синтаксиса я использовал [highlight.js](https://highlightjs.org/). Пример подключения можно посмотреть на странице [демо remarkable](https://jonschlinkert.github.io/remarkable/demo/).


## Заключение

Настала пора подводить итоги. Парсер для моего сайта выбран и настроен, чем вы имеете удовольствие пользоваться, читая эту статью в этом блоге.

Работая над статьей, я узнал много нового про Markdown и открыл его для себя с новой стороны.

Буду рад, если вам понравилось читать это небольшое исследование. До новых встреч, всем добра!


